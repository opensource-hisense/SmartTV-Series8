#include <mtk_msdc.h>
#include <mtk_msdc_dbg.h>

#if defined(CONFIG_ARCH_MT5399) || defined(CONFIG_ARCH_MT5882)
static const EMMC_FLASH_DEV_T _arEMMC_DevInfo[] =
{
	// Device name										   ID1				 ID2			 DS26Sample		  DS26Delay		HS52Sample		HS52Delay			 DDR52Sample	  DDR52Delay	   HS200Sample		HS200Delay
	//HS200Delay ,0x:MSDC_PB1_WRDAT_CRCS_TA_CNTR,MSDC_PB0_CKGEN_MSDC_DLY_SEL,PAD_DAT_RD_RXDLY,PAD_DAT_WR_RXDLY
	{"UNKNOWN",						0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x1861001c, 0x01000100, 0x00000102, 0x0000000A, 0x00000102, 0x0000030D},
	{"H26M21001ECR",				0x4A48594E, 0x49582056, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x00000000, 0x00000006, 0x00000000},
	{"H26M31003FPR",				0x4A205849, 0x4E594812, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x00000000, 0x00000006, 0x00000000},
	{"H26M31003GMR",				0x4A483447, 0x31640402, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x00000000, 0x00000002, 0x0000030D},
	{"H26M31001HPR",				0x4A483447, 0x32611101, 0x00000000, 0x00000000, 0x00010000, 0x01000010, 0x00000002, 0x03000d0d, 0x00000002, 0x03060d0f},
	{"H26M52103FMR",				0x4A484147, 0x32650502, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000002, 0x00040F0F, 0x00000100, 0x04150917},
	{"H26M41103HPR",				0x4A483847, 0x31650502, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000002, 0x00000F0F, 0x00000000, 0x030a080f},
	{"SDIN5D2-4G",					0x0053454D, 0x30344790, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x00000000, 0x00000002, 0x0000030D},
	{"KLM2G1HE3F-B001",				0x004D3247, 0x31484602, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x00000000, 0x00000006, 0x00000000},
	{"KLM8G1GEAC-B031xxx",			0x004D3847, 0x3147430B, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000002, 0x00000F0F, 0x00000002, 0x0309090C},
	{"KLMAG2GEAC-B031000",			0x004D4147, 0x3247430B, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x00040F0F, 0x00000002, 0x0309090C},
	{"THGBM3G4D1FBAIG",				0x00303032, 0x47303000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x00000000, 0x00000006, 0x00000000},
	{"THGBM4G4D1FBAIG",				0x00303032, 0x47343900, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x00000000, 0x00000006, 0x00000000},
	{"THGBM4G5D1HBAIR",				0x00303034, 0x47343900, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x00000000, 0x00000006, 0x00000000},
	{"THGBM4G6D2HBAIR",				0x00303038, 0x47344200, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x00000000, 0x00000006, 0x00000000},
	{"MTFC8GACAAAM-1M WT",			0x4E503158, 0x58585812, 0x00000000, 0x00000000, 0x1861001c, 0x01000100, 0x00000002, 0x03000d0d, 0x00110501, 0x01040001},// JWA61
	{"MTFC8GACAEAM-1M WT",			0x4E52314A, 0x35354110, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x0000130F, 0x00000000, 0x030B090C},
	{"MTFC4GACAEAM-1M WT",			0x4E52314A, 0x35344110, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x0000130F, 0x00000002, 0x02060808},//JWA80
	{"MTFC4GACAAAM-1M WT",			0x4E503158, 0x58585812, 0x00000000, 0x00000000, 0x1861001c, 0x01000100, 0x00000002, 0x03000d0d, 0x00110501, 0x01040001},
	{"MTFC4GMVEA-1M WT(JW857)",		0x4E4D4D43, 0x3034473A, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x0000000A, 0x00000006, 0x00000000},
	{"MTFC2GMVEA-0M WT(JW896)",		0x4E4D4D43, 0x3032473A, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x0000000A, 0x00000006, 0x00000000},
	{"MTFC8GLCDM-1M WT(JW962)",		0x4E503158, 0x58585814, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x0000000A, 0x00000102, 0x1800030D},
	{"THGBMAG6A2JBAIR",				0x00303038, 0x47393251, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x0000130F, 0x00000002, 0x0309080C},
	{"THGBM5G6A2JBAIR",				0x00303038, 0x47393200, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x0000000A, 0x00000102, 0x0000030D},
	{"THGBMBG5D1KBAIT",				0x00303034, 0x47453000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x0000130F, 0x00000002, 0x0306090a},
	{"THGBMAG5A1JBAIR",				0x00303034, 0x47393051, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x0000000A, 0x00000102, 0x0000030D},
	{"THGBMAG7A2JBAIR",				0x00303136, 0x47393201, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x0000000A, 0x00000102, 0x0000030D},
	{"THGBMAG6A2JBAIR",				0x00303038, 0x47393251, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x0000130F, 0x00000002, 0x0309080C},
	{"THGBMBG6D1KBAIL-XXX",			0x00303038, 0x47453000, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x0000130F, 0x00000002, 0x0309090C},
};
#endif

#if defined(CONFIG_ARCH_MT5890) || defined(CONFIG_ARCH_MT5891)
static const EMMC_FLASH_DEV_T _arEMMC_DevInfo[] =
{
	// Device name					ID1			ID2		DS26Sample	DS26Delay	HS52Sample	HS52Delay	DDR52Sample DDR52Delay	HS200Sample HS200Delay//HS200Delay ,0x:MSDC_PB1_WRDAT_CRCS_TA_CNTR,MSDC_PB0_CKGEN_MSDC_DLY_SEL,PAD_DAT_RD_RXDLY,PAD_DAT_WR_RXDLY
	{"UNKNOWN",					0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x1861001c, 0x01000100, 0x00000102, 0x0000000A, 0x00000102, 0x0000030D},
	{"H26M21001ECR",			0x4A48594E, 0x49582056, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x00000000, 0x00000006, 0x00000000},
	{"H26M31003FPR",			0x4A205849, 0x4E594812, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x00000000, 0x00000006, 0x00000000},
	{"H26M31003GMR",			0x4A483447, 0x31640402, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x00000000, 0x00000002, 0x0000030D},
	{"H26M31001HPR",			0x4A483447, 0x32611101, 0x00000000, 0x00000000, 0x1861001c, 0x01000100, 0x00000002, 0x00000F0F, 0x00000002, 0x02090D08},
	{"H26M52103FMR",			0x4A484147, 0x32650502, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000002, 0x00040F0F, 0x00000100, 0x04150917},
	{"H26M41103HPR",			0x4A483847, 0x31650502, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000002, 0x00000F0F, 0x00000000, 0x030a080f},
	{"SDIN5D2-4G",				0x0053454D, 0x30344790, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x00000000, 0x00000002, 0x0000030D},
	{"KLM2G1HE3F-B001",			0x004D3247, 0x31484602, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x00000000, 0x00000006, 0x00000000},
	{"KLM8G1GEND-B031",			0x0038474E, 0x44335201, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000002, 0x03000d0d, 0x00000002, 0x0309080c},
	{"KLMAG2GEND-B031",			0x0041474E, 0x44335201, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000002, 0x03000d0d, 0x00000002, 0x0309080c},
	{"KLM8G1GEAC-B031xxx",		0x004D3847, 0x3147430B, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000002, 0x00000F0F, 0x00000002, 0x0309090C},
	{"KLMAG2GEAC-B031000",		0x004D4147, 0x3247430B, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x00040F0F, 0x00000002, 0x0309090C},
	{"THGBM3G4D1FBAIG",			0x00303032, 0x47303000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x00000000, 0x00000006, 0x00000000},
	{"THGBM4G4D1FBAIG",			0x00303032, 0x47343900, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x00000000, 0x00000006, 0x00000000},
	{"THGBM4G5D1HBAIR",			0x00303034, 0x47343900, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x00000000, 0x00000006, 0x00000000},
	{"THGBM4G6D2HBAIR",			0x00303038, 0x47344200, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x00000000, 0x00000006, 0x00000000},
	{"THGBMBG5D1KBAIL",			0x00303034, 0x47453000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x00000000, 0x00000002, 0x04060315},
	{"MTFC8GACAAAM-1M WT",		0x4E503158, 0x58585812, 0x00000000, 0x00000000, 0x00000106, 0x0105150F, 0x00000002, 0x03000d0d, 0x00000100, 0x04080818},// JWA61
	{"MTFC8GACAEAM-1M WT",		0x4E52314A, 0x35354110, 0x00000000, 0x00000000, 0x00000006, 0x00000F0F, 0x00000102, 0x0000130F, 0x00000000, 0x030B090C},
	{"MTFC4GMVEA-1M WT(JW857)", 0x4E4D4D43, 0x3034473A, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x0000000A, 0x00000006, 0x00000000},
	{"MTFC2GMVEA-0M WT(JW896)", 0x4E4D4D43, 0x3032473A, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x0000000A, 0x00000006, 0x00000000},
	{"MTFC8GLCDM-1M WT(JW962)", 0x4E503158, 0x58585814, 0x00000000, 0x00000000, 0x00000004, 0x00000000, 0x00000102, 0x0000000A, 0x00000102, 0x1800030D},
	{"THGBMAG6A2JBAIR",			0x00303038, 0x47393251, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x0000130F, 0x00000002, 0x0309080C},
	{"THGBM5G6A2JBAIR",			0x00303038, 0x47393200, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x0000000A, 0x00000102, 0x0000030D},
	{"THGBMAG5A1JBAIR",			0x00303034, 0x47393051, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x0000000A, 0x00000102, 0x0000030D},
	{"THGBMAG7A2JBAIR",			0x00303136, 0x47393201, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x0000000A, 0x00000102, 0x0000030D},
	{"THGBMAG6A2JBAIR",			0x00303038, 0x47393251, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x0000130F, 0x00000002, 0x0309080C},
	{"THGBMBG6D1KBAIL-XXX",		0x00303038, 0x47453000, 0x00000000, 0x00000000, 0x00000006, 0x00000F0F, 0x00000102, 0x0000130F, 0x00000002, 0x0309090C},

	//for wukong toshiba 16nm,sdr50
	{ "THGBMFG7C1LBAIL",		0x00303136, 0x47373000, 0x00000000, 0x00000000, 0x00010000, 0x01000100, 0x00000000, 0x00000000, 0x00000102, 0x0000030A},
	//for wukong toshiba 19nm,sdr50
	{ "THGBMFG7D2KBAIL",		0x00303136, 0x47453200, 0x00000000, 0x00000000, 0x00010000, 0x01000100, 0x00000000, 0x00000000, 0x00000102, 0x0000030A},
};
#endif

#if defined(CONFIG_ARCH_MT5883)
static const EMMC_FLASH_DEV_T _arEMMC_DevInfo[] =
{
	// Device name                     ID1         ID2      DS26Sample  DS26Delay   HS52Sample  HS52Delay  DDR52Sample  DDR52Delay  HS200Sample HS200Delay
	//HS200Delay ,0x:MSDC_PB1_WRDAT_CRCS_TA_CNTR,MSDC_PB0_CKGEN_MSDC_DLY_SEL,PAD_DAT_RD_RXDLY,PAD_DAT_WR_RXDLY
	//HS200Common:MSDC_PB0_INT_DAT_LATCH_CK_SEL , MSDC_PB0_CKGEN_MSDC_DLY_SEL
	{"UNKNOWN",					0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x0000000A, 0x00000102, 0x0000030D},
	{"MTFC8GACAECN-1M WT",		0x4E52314A, 0x35354111, 0x00000000, 0x00000000, 0x1861001c, 0x01000100, 0x00000102, 0x0000130F, 0x00400802, 0x00150000},
};
#endif

#if defined(CONFIG_ARCH_MT5882)
static const EMMC_FLASH_DEV_T _arEMMC_DevInfo_Lemurplus[] =
{
   // Device name              ID1         ID2      DS26Sample  DS26Delay   HS52Sample  HS52Delay   DDR52Sample DDR52Delay  HS200Sample HS200Delay
   //HS200Sample:MSDC_PAD_TUNE_CMDRRDLY,MSDC_IOCON_RSPL,MSDC_PAD_TUNE_CMDRDLY,PAD_TUNE_DAT_WRDLY,
   //HS200Delay :MSDC_IOCON_W_D_SPL,MSDC_DAT_RDDLY0_D0,MSDC_IOCON_R_SMPL,PAD_DAT_RD_RXDLY
   //HS200Common:INT_DAT_LATCH_CK_SEL , MSDC_CKGEN_MSDC_DLY_SEL
  {"UNKNOWN",			    0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x0000000A, 0x00000102, 0x0000030D},
  {"KLM2G1HE3F-B001",		0x004D3247, 0x31484602, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x00000000, 0x00000006, 0x00000000},
  {"KLM4G1FEPD-B001",		0x00344650, 0x44335202, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x00000000, 0x00010E00, 0x010A0100},
  {"KLMAG2GEAC-B031000",	0x004D4147, 0x3247430B, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x00040F0F, 0x00000002, 0x0309090C},
  {"THGBMBG5D1KBAIL",		0x00303034, 0x47453000, 0x00000000, 0x00000000, 0x00001F00, 0x001F0010, 0x00000102, 0x0000130F, 0x05110306, 0x01030115},
  {"THGBMBG5D1KBAIT",		0x00303034, 0x47453000, 0x00000000, 0x00000000, 0x00001F00, 0x001F0010, 0x00000102, 0x0000130F, 0x05110306, 0x01030115},
  {"H26M31001HPR",		    0x4A483447, 0x32611101, 0x00000000, 0x00000F0F, 0x00010000, 0x01000010, 0x00000002, 0x03000d0d, 0x00000002, 0x03060d0f},
  {"MTFC4GACAAAM-1M WT",	0x4E503158, 0x58585812, 0x00000000, 0x00000000, 0x1861001c, 0x01000100, 0x00000002, 0x03000d0d, 0x00200601, 0x01010004},
  {"SDIN9D2-8G",            0x00445332, 0x30303801, 0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00000102, 0x00000000, 0x0910090B, 0x00070005},
};
#endif

#if defined(CONFIG_ARCH_MT5890)
static const EMMC_FLASH_DEV_T _arEMMC_DevInfo_ett_oryx[] =
{
	// Device name				ID1			ID2			DS26Sample	DS26Delay	HS52Sample	HS52Delay	DDR52Sample DDR52Delay	HS200Sample HS200Delay	//HS200Delay ,0x:MSDC_PB1_WRDAT_CRCS_TA_CNTR,MSDC_PB0_CKGEN_MSDC_DLY_SEL,PAD_DAT_RD_RXDLY,PAD_DAT_WR_RXDLY
	{"UNKNOWN",					0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x1861001c, 0x01000100, 0x00000000, 0x00000000, 0x00000102, 0x0000030A},
	{"MTFC8GACAAAM-1M WT",		0x4E503158, 0x58585812, 0x00000000, 0x00000000, 0x11011f1a, 0x011f0110, 0x00000000, 0x00000000, 0x00000002, 0x03020815},// JWA61
	{"SP18A4G751B-0003_4G",		0x11373531, 0x30303010, 0x00000000, 0x00000000, 0x1861001c, 0x01000100, 0x00000000, 0x00000000, 0x01100d01, 0x0000000a},
	{"SP18A8G861B-0003_8G_NEW", 0x11383631, 0x30303010, 0x00000000, 0x00000000, 0x1861001c, 0x01000100, 0x00000000, 0x00000000, 0x01100d01, 0x0000000a},
	{"SP18A8G861B-0003_8G_OLD", 0x4d303030, 0x303010b1, 0x00000000, 0x00000000, 0x1861001c, 0x01000100, 0x00000000, 0x00000000, 0x01100d01, 0x0000000a},
	{"SP18A8G861B-0003_16G",	0x11383632, 0x30303010, 0x00000000, 0x00000000, 0x1861001c, 0x01000100, 0x00000000, 0x00000000, 0x01100d01, 0x0000000a},

	//Micron,need confirm HS200
	{ "JW904",					   0x4e503058, 0x58585801, 0x00000000, 0x00000000, 0x1f000f1f, 0x0017000f, 0x00000000, 0x00000000, 0x00800000, 0x0000000a},
	//toshiba,need confirm SDR50
	{ "TMGBMBG5D1KBAIL",		   0x303034,   0x47453000, 0x00000000, 0x00000000, 0x06901906, 0x001c000c, 0x00000000, 0x00000000, 0x06901906, 0x001c000c},
	//samsung,need confirm SDR50
	{"KLM8G1GEAC-B031_8G",		   0x004d3847, 0x31474305, 0x00000000, 0x00000000, 0x1861001c, 0x01000100, 0x00000000, 0x00000000, 0x0E800D08, 0x000C0003},

	//Hynix, support SDR50,HS200
	{"H26M41103HPR",			  0x4a483847, 0x31650507, 0x00000000, 0x00000000, 0x0f800f0f, 0x000f000f, 0x00000000, 0x00000000, 0x06800B0B, 0x000C0008},
	  //20150918,sync from SN
	{"THGBMFG7C2LBAIL-XXX",     0x00303136, 0x47373200, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x0000130F,  0x00100600, 0x00060000},
	{"THGBMFG7C2LBAIL-XXX",     0x00303136, 0x47373204, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x0000130F,  0x00100600, 0x00060000},
	{"KLMAG1JENB",              0x00414A4E, 0x42345201, 0x00000000, 0x00000000, 0x00000006, 0x00000000, 0x00000102, 0x0000130F,  0x0C800B1F, 0x00100000},

	//for wukong toshiba 16nm,sdr50
	{ "THGBMFG7C1LBAIL",		0x00303136, 0x47373000, 0x00000000, 0x00000000, 0x00010000, 0x01000100, 0x00000000, 0x00000000, 0x00000102, 0x0000030A},
	//for wukong toshiba 19nm,sdr50
	{ "THGBMFG7D2KBAIL",		0x00303136, 0x47453200, 0x00000000, 0x00000000, 0x00010000, 0x01000100, 0x00000000, 0x00000000, 0x00000102, 0x0000030A},
};

static const EMMC_FLASH_DEV_T _arEMMC_DevInfo_ett_gazelle[] =
{
	// Device name				ID1			ID2			DS26Sample	DS26Delay	HS52Sample	HS52Delay	DDR52Sample DDR52Delay	HS200Sample HS200Delay	//HS200Delay ,0x:MSDC_PB1_WRDAT_CRCS_TA_CNTR,MSDC_PB0_CKGEN_MSDC_DLY_SEL,PAD_DAT_RD_RXDLY,PAD_DAT_WR_RXDLY
	{"UNKNOWN",					0x00000000, 0x00000000, 0x00000000, 0x00000000, 0x00010000, 0x01000100, 0x00000000, 0x00000000, 0x00000102, 0x0000030A},
	{"MTFC8GACAAAM-1M WT",		0x4E503158, 0x58585812, 0x00000000, 0x00000000, 0x1861001c, 0x01000100, 0x00000000, 0x00000000, 0x00000002, 0x03020815},// JWA61
	{"SP18A4G751B-0003_4G",		0x11373531, 0x30303010, 0x00000000, 0x00000000, 0x1f80121f, 0x0015000f, 0x00000000, 0x00000000, 0x07201807, 0x00190003},
	{"SP18A8G861B-0003_8G_NEW", 0x11383631, 0x30303010, 0x00000000, 0x00000000, 0x1f80121f, 0x0015000f, 0x00000000, 0x00000000, 0x07201807, 0x00190003},
	{"SP18A8G861B-0003_8G_OLD", 0x4d303030, 0x303010b1, 0x00000000, 0x00000000, 0x1f80121f, 0x0015000f, 0x00000000, 0x00000000, 0x07201807, 0x00190003},
	{"SP18A8G861B-0003_16G",	0x11383632, 0x30303010, 0x00000000, 0x00000000, 0x1f80121f, 0x0015000f, 0x00000000, 0x00000000, 0x07201807, 0x00190003},
	{"THGBMBG7D2KBAIL",			0x00303136, 0x47453200, 0x00000000, 0x00000000, 0x00010000, 0x01000100, 0x00000000, 0x00000000, 0x00E00000, 0x00000000},
	{"KLM8G1GEND-B031",			0x0038474E, 0x44335201, 0x00000000, 0x00000000, 0x00010000, 0x01000100, 0x00000000, 0x00000000, 0x10700410, 0x00040004},
	{"THGBMFG6C1LBAIL",			0x00303038, 0x47373000, 0x00000000, 0x00000000, 0x00010000, 0x01000100, 0x00000000, 0x00000000, 0x0FE0000E, 0x00020000},
};
#endif

static u32 msdc_which_ett(const EMMC_FLASH_DEV_T **ett)
{
#if defined(CONFIG_ARCH_MT5890)
	if (IS_IC_MT5890()) {
		*ett = &_arEMMC_DevInfo_ett_oryx[0];
		return sizeof(_arEMMC_DevInfo_ett_oryx) / sizeof(EMMC_FLASH_DEV_T);
	} else if (IS_IC_MT5861()) {
		*ett = &_arEMMC_DevInfo_ett_gazelle[0];
		return sizeof(_arEMMC_DevInfo_ett_gazelle) / sizeof(EMMC_FLASH_DEV_T);
	} else
#endif
#if defined(CONFIG_ARCH_MT5882)
	if (IS_IC_MT5885()) {
		*ett = &_arEMMC_DevInfo_Lemurplus[0];
		return sizeof(_arEMMC_DevInfo_Lemurplus) / sizeof(EMMC_FLASH_DEV_T);
	} else
#endif
	*ett = &_arEMMC_DevInfo[0];
	return sizeof(_arEMMC_DevInfo) / sizeof(EMMC_FLASH_DEV_T);
}

static u32 emmcidx = 0xFFFFFFFF;
static void msdc_find_dev(u32 *pCID)
{
	u32 i, devNum;
	/*
	 * why we need to define the id mask of emmc
	 * Some vendors' emmc has the same brand & type but different product revision.
	 * That means the firmware in eMMC has different revision
	 * We should treat these emmcs as same type and timing
	 * So id mask can ignore this case
	 */
	u32 idMask = 0xFFFFFF00;
	u32 id1, id2;
	const EMMC_FLASH_DEV_T *ett;

	if (pCID == NULL) {
		emmcidx = 0;
		return;
	}

	id1 = ((pCID[0] & 0xFFFF) << 16) | ((pCID[1] & (0xFFFF << 16)) >> 16);
	id2 = ((pCID[1] & 0xFFFF) << 16) | ((pCID[2] & (0xFFFF << 16)) >> 16);
	pr_debug("%s => CID: %08X:%08X:%08X:%08X\n", __func__,
		pCID[0], pCID[1], pCID[2], pCID[3]);
	pr_debug("%s => id1:%08X id2:%08X\n", __func__, id1, id2);

	devNum = msdc_which_ett(&ett);

	for (i = 0; i < devNum; i++) {
		if ((ett[i].u4ID1 == id1) &&
			((ett[i].u4ID2 & idMask) == (id2 & idMask)))
			break;
	}

	emmcidx = (i == devNum) ? 0 : i;
	pr_err("eMMC Name: %s\n", ett[emmcidx].acName);
}

static void msdc_sample_delay(struct mmc_host *mmc)
{

	const EMMC_FLASH_DEV_T *ett;
	struct msdc_host *host = mmc_priv(mmc);
	u32 __iomem *base = host->base;
	u32 u4Sample = 0;
	u32 u4Delay = 0;

	#if defined(CONFIG_ARCH_MT5882)
    //MT5885 default use async-fifo path, currently we change to use delay-line path as default
	if (IS_IC_MT5885()) {
		pr_err("[ZJ] switch to ETT module\n");
		/* Bit[28]=0  */
		sdr_set_field(MSDC_PATCH_BIT2, MSDC_PB2_CFGCRCSTS, 0);

		/* Bit[15]=1 */
		sdr_set_field(MSDC_PATCH_BIT2, MSDC_PB2_CFGRESP, 1);
		//sdr_set_bits(MSDC_PATCH_BIT2, 0x1 << CFG_RESP_SHIFT);

		/* Bit[9]= 1 */
		sdr_set_field(MSDC_PATCH_BIT2, MSDC_PB2_CFGRDAT, 1);
		//sdr_set_bits(MSDC_PATCH_BIT2, 0x1 << CFG_RDAT_SHIFT);

		/* Bit[15]=1 */
		sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_RXDLYSEL, 1);
		//sdr_set_bits(MSDC_PAD_TUNE0, 0x1 << MSDC_PAD_RXDLY_SEL_SHIFT);
	}
	#endif

	msdc_which_ett(&ett);

	// Sample Edge init
	sdr_clr_bits(MSDC_PAD_TUNE0, 0xFFFFFFFF);

	// Sample Edge init
	if (mmc->ios.timing == MMC_TIMING_LEGACY)
		sdr_set_bits(MSDC_PAD_TUNE0, ett[emmcidx].DS26Delay);
	else if (mmc->ios.timing == MMC_TIMING_MMC_HS) {
#if defined(CONFIG_ARCH_MT5890) || defined(CONFIG_ARCH_MT5883) || \
	defined(CONFIG_ARCH_MT5891) || defined(CONFIG_ARCH_MT5882)
		u4Sample = ett[emmcidx].HS52Sample;
		u4Delay = ett[emmcidx].HS52Delay;
		ERR_MSG("[Kernel] SDR50 param 0x%x , 0x%x \n", u4Sample, u4Delay);

		/*++++++++++++++++++++++clock part+++++++++++++++++++*/
		sdr_set_field(MSDC_PATCH_BIT0, MSDC_PB0_INT_DAT_LATCH_CK_SEL, 0);
		sdr_set_field(MSDC_PATCH_BIT0, MSDC_PB0_CKGEN_MSDC_DLY_SEL, (u4Sample & 0x00f00000) >> 20);

		/*++++++++++++++++++++++cmd part+++++++++++++++++++*/
		sdr_set_field(MSDC_PATCH_BIT1, MSDC_PB1_CMD_RSP_TA_CNTR, 1);
		sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_CMDRRDLY, (u4Sample & 0x1f000000) >> 24);
		sdr_set_field(MSDC_IOCON, MSDC_IOCON_RSPL, (u4Sample & 0x00010000) >> 16);
		sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_CMDRDLY, (u4Sample & 0x00001f00) >> 8);

		/*++++++++++++++++++++++write part+++++++++++++++++++*/
		sdr_set_field(MSDC_PATCH_BIT1, MSDC_PB1_WRDAT_CRCS_TA_CNTR, 1);
		sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_DATWRDLY, u4Sample & 0x0000001f);
		sdr_set_field(MSDC_IOCON, MSDC_IOCON_W_D_SMPL_SEL, 0);
		sdr_set_field(MSDC_IOCON, MSDC_IOCON_W_D_SMPL, (u4Delay & 0x01000000) >> 24);
		sdr_set_field(MSDC_DAT_RDDLY0, MSDC_DAT_RDDLY0_D0, (u4Delay & 0x001f0000) >> 16);

		/*++++++++++++++++++++++read part+++++++++++++++++++*/
		sdr_set_field(MSDC_IOCON, MSDC_IOCON_R_D_SMPL, (u4Delay & 0x00000100) >> 8);
		sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_DATRRDLY, u4Delay & 0x0000001f);
#else
		sdr_set_bits(MSDC_PAD_TUNE0, ett[emmcidx].HS52Delay);
		sdr_set_field(MSDC_PATCH_BIT0, MSDC_PB0_CKGEN_MSDC_DLY_SEL, 1);
#endif
	} else if (mmc->ios.timing == MMC_TIMING_UHS_DDR50) {
		ERR_MSG("[Kernel] DDR50\n");
		sdr_set_bits(MSDC_PAD_TUNE0, ett[emmcidx].DDR52Delay & 0xffff);
		sdr_set_field(MSDC_PATCH_BIT0, MSDC_PB0_CKGEN_MSDC_DLY_SEL, (ett[emmcidx].DDR52Delay & 0x00ff0000) >> 16);
	} else if (mmc->ios.timing == MMC_TIMING_MMC_HS200) {
		u4Sample = ett[emmcidx].HS200Sample;
		u4Delay = ett[emmcidx].HS200Delay;
		ERR_MSG("[Kernel] HS200 param 0x%x , 0x%x\n", u4Sample, u4Delay);

	#if defined(CONFIG_ARCH_MT5890)
		if (IS_IC_MT5890() || IS_IC_MT5861()) {
		#ifdef CC_EMMC_KDELAY
			u32 wDelay_para, wCMD_tmp, wWrite_tmp;
			u32 kdelay;

			if (IS_IC_MT5890())
				kdelay = MT5890_TT_KDELAY;
			else
				kdelay = MT5861_TT_KDELAY;
		#endif

			/*++++++++++++++++++++++clock part+++++++++++++++++++*/
			sdr_set_field(MSDC_PATCH_BIT0, MSDC_PB0_INT_DAT_LATCH_CK_SEL, 0);
			sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_CLKTXDLY, 8);
			sdr_set_field(MSDC_PATCH_BIT0, MSDC_PB0_CKGEN_MSDC_DLY_SEL, (u4Sample & 0x00f00000) >> 20);

			/*++++++++++++++++++++++cmd part+++++++++++++++++++*/
			sdr_set_field(MSDC_PATCH_BIT1, MSDC_PB1_CMD_RSP_TA_CNTR, 1);

		#ifdef CC_EMMC_KDELAY
			sdr_get_field(MSDC_DBG_SEL, (0xFFFF << 0), wDelay_para);
			ERR_MSG("Kdelay val %d\n", wDelay_para);
			if ((wDelay_para > 100) || (wDelay_para < 40)) {
				ERR_MSG("[EMMC_KDELAY] Kdelay out of range, using default value\n");
				sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_CMDRRDLY, (u4Sample & 0x1f000000) >> 24);
				sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_DATWRDLY, u4Sample & 0x0000001f);
			} else {
				wCMD_tmp = (u4Sample & 0x1f000000) >> 24;
				wWrite_tmp = (u4Sample & 0x0000001f);
				if (wDelay_para > kdelay) {
					wDelay_para -= kdelay;
					wCMD_tmp = wCMD_tmp + wDelay_para;
					wWrite_tmp = wWrite_tmp + wDelay_para;
				} else {
					wDelay_para = kdelay - wDelay_para;

					wCMD_tmp = (wCMD_tmp >= wDelay_para)? (wCMD_tmp - wDelay_para) : (wCMD_tmp + 32 - wDelay_para);
					wWrite_tmp = (wWrite_tmp >= wDelay_para)? (wWrite_tmp - wDelay_para) : (wWrite_tmp + 32 - wDelay_para);
				}
				wCMD_tmp = wCMD_tmp & 0x1F;
				wWrite_tmp = wWrite_tmp & 0x1F;
				sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_CMDRRDLY, wCMD_tmp);
				sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_DATWRDLY, wWrite_tmp);
				ERR_MSG("[EMMC_KDELAY] wDelay_para = %d, wCMD_tmp = %d, wWrite_tmp = %d\n",
						wDelay_para,wCMD_tmp,wWrite_tmp);
			}
		#else
			sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_CMDRRDLY, (u4Sample & 0x1f000000) >> 24);
		#endif

			sdr_set_field(MSDC_IOCON, MSDC_IOCON_RSPL, (u4Sample & 0x00010000) >> 16);
			sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_CMDRDLY, (u4Sample & 0x00001f00) >> 8);

			/*++++++++++++++++++++++write part+++++++++++++++++++*/
			sdr_set_field(MSDC_PATCH_BIT1, MSDC_PB1_WRDAT_CRCS_TA_CNTR, 1);

		#ifndef CC_EMMC_KDELAY
			sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_DATWRDLY, u4Sample & 0x0000001f);
		#endif

			sdr_set_field(MSDC_IOCON, MSDC_IOCON_W_D_SMPL, (u4Delay & 0x01000000) >> 24);
			sdr_set_field(MSDC_DAT_RDDLY0, MSDC_DAT_RDDLY0_D0, (u4Delay & 0x001f0000) >> 16);

			/*++++++++++++++++++++++read part+++++++++++++++++++*/
			sdr_set_field(MSDC_IOCON, MSDC_IOCON_R_D_SMPL, (u4Delay & 0x00000100) >> 8);
			sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_DATRRDLY, u4Delay & 0x0000001f);
		} else
	#endif /* CONFIG_ARCH_MT5890 */
		{
			/*++++++++++++++++++++++clock part+++++++++++++++++++*/
		#if defined(CONFIG_ARCH_MT5883)
			sdr_set_field(MSDC_PATCH_BIT0, MSDC_PB0_INT_DAT_LATCH_CK_SEL, 1);
			sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_CLKTXDLY, 0x6);
		#else
			#if defined(CONFIG_ARCH_MT5882)
			if(IS_IC_MT5885()) {
				sdr_set_field(MSDC_PATCH_BIT0, MSDC_PB0_INT_DAT_LATCH_CK_SEL, 0);
				sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_CLKTXDLY, 0x0);
			} else {
				sdr_set_field(MSDC_PATCH_BIT0, MSDC_PB0_INT_DAT_LATCH_CK_SEL, 0);
				sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_CLKTXDLY, 0xc);
			}
			#else
			sdr_set_field(MSDC_PATCH_BIT0, MSDC_PB0_INT_DAT_LATCH_CK_SEL, 0);
			sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_CLKTXDLY, 0xc);
			#endif
		#endif

			sdr_set_field(MSDC_PATCH_BIT0, MSDC_PB0_CKGEN_MSDC_DLY_SEL, (u4Sample & 0x00f00000) >> 20);

			/*++++++++++++++++++++++cmd part+++++++++++++++++++*/
			sdr_set_field(MSDC_PATCH_BIT1, MSDC_PB1_CMD_RSP_TA_CNTR, 1);
			sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_CMDRRDLY, (u4Sample & 0x1f000000) >> 24);
			sdr_set_field(MSDC_IOCON, MSDC_IOCON_RSPL, (u4Sample & 0x00010000) >> 16);
			sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_CMDRDLY, (u4Sample & 0x00001f00) >> 8);

			/*++++++++++++++++++++++write part+++++++++++++++++++*/
			sdr_set_field(MSDC_PATCH_BIT1, MSDC_PB1_WRDAT_CRCS_TA_CNTR, 1);
			sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_DATWRDLY, u4Sample & 0x0000001f);
			sdr_set_field(MSDC_IOCON, MSDC_IOCON_W_D_SMPL_SEL, 0);
			sdr_set_field(MSDC_IOCON, MSDC_IOCON_W_D_SMPL, (u4Delay & 0x01000000) >> 24);
			sdr_set_field(MSDC_DAT_RDDLY0, MSDC_DAT_RDDLY0_D0, (u4Delay & 0x001f0000) >> 16);

			/*++++++++++++++++++++++read part+++++++++++++++++++*/
			sdr_set_field(MSDC_IOCON, MSDC_IOCON_R_D_SMPL, (u4Delay & 0x00000100) >> 8);
			sdr_set_field(MSDC_PAD_TUNE0, MSDC_PAD_TUNE0_DATRRDLY, u4Delay & 0x0000001f);
		}
	}
}

static void msdc_sample_edge(struct mmc_host *mmc)
{
	struct msdc_host *host = mmc_priv(mmc);
	u32 __iomem *base = host->base;
	const EMMC_FLASH_DEV_T *ett;

	msdc_which_ett(&ett);
	// Sample Edge init
	sdr_clr_bits(MSDC_IOCON, 0xFFFFFF);

	// Sample Edge init
	if (mmc->ios.timing == MMC_TIMING_LEGACY)
		sdr_set_bits(MSDC_IOCON, _arEMMC_DevInfo[emmcidx].DS26Sample & 0xFFFFFF);
	else if (mmc->ios.timing == MMC_TIMING_MMC_HS) {
#if defined(CONFIG_ARCH_MT5399)
	   sdr_set_bits(MSDC_IOCON, _arEMMC_DevInfo[emmcidx].HS52Sample & 0xFFFFFF);
#endif
	} else if (mmc->ios.timing == MMC_TIMING_UHS_DDR50) {
		sdr_set_bits(MSDC_IOCON, ett[emmcidx].DDR52Sample & 0xFFFFFF);
	#ifndef MSDC_ONLY_USE_ONE_CLKSRC
		sdr_write32(host->hclk_base, 0x2);
	#endif
	} else if (mmc->ios.timing == MMC_TIMING_MMC_HS200) {
		//sdr_set_bits(MSDC_IOCON, _arEMMC_DevInfo[emmcidx].HS200Sample & 0xFFFFFF);
#ifndef MSDC_ONLY_USE_ONE_CLKSRC
		sdr_write32(host->hclk_base, 0x2);
#endif
	}
}

static void msdc_load_ett_settings(struct mmc_host *mmc)
{
	if (mmc == NULL) {
		pr_err("%s => ERROR: mmc is NULL!\n", __func__);
		return;
	}
	msdc_sample_delay(mmc);
	msdc_sample_edge(mmc);
}

/* SD card use runtime online tune */
void msdc_register_ett(struct msdc_host *host, u32 *cid)
{
	if (unlikely(host->load_ett_settings == NULL &&
		host->hw->host_function == MSDC_EMMC)) {
		msdc_find_dev(cid);
		host->load_ett_settings = msdc_load_ett_settings;
	}
}

